- TCP (Transmission Control Protocol): 신뢰할 수 있는 통신을 위한 연결형 프로토콜
- UDP (User Datagram Protocol): TCP보다 신뢰성을 떨어지지만 비교적 빠른 통신이 가능한 비연결형 프로토콜
<br/>

## TCP 통신 단계와 세그먼트 구조
- 세그먼트
  - TCP에서 데이터를 전송할 때 사용하는 데이터의 단위
  - TCP 세그먼트 = TCP 헤더 + 페이로드
- TCP: 통신하기 전에 연결을 수립하고 끝나면 연결을 종료
- **MSS** (Maximum Segment Size)
  - TCP로 전송할 수 있는 최대 페이로드 크기
  - ⚠️ TCP 헤더 제외 (헤더까지 포함하는 MTU (한 번에 전송 가능한 IP 패킷의 최대 크기)와는 대조적)
- TCP 헤더의 중요 필드
  - 송신지 포트 & 수신지 포트
  - **순서 번호** (sequence number): 송수신되는 세그먼트의 올바른 순서를 보장하기 위해 세그먼트 데이터의 첫 바이트에 부여되는 번호
  - **확인 응답 번호** (acknowledgment number)
    - 상대 호스트가 보낸 세그먼트에 대한 응답
    - 다음으로 수신하기를 기대하는 순서 번호가 명시
  - 제어 비트 (control bit, 플래그 비트): 현재 세그먼트에 대한 부가 정보
  - 윈도우 (window)
    - 수신 윈도우의 크기 명시
    - 수신 윈도우: 한 번에 수신하고자 하는 데이터의 양
### 제어 비트 
- 기본적으로 8비트로 구성
- 주요 제어 비트
  - ACK: 세그먼트의 승인을 나타내기 위한 비트
  - SYN: 연결을 수립하기 위한 비트
  - FIN: 연결을 종료하기 위한 비트
### ⭐ 순서 번호 & 확인 응답 번호
- 순서 번호
  - 순서 번호
    - 순서 번호 필드에 명시
    - 세그먼트의 올바른 송수신 순서를 보장하기 위한 번호
    - 세그먼트 데이터의 첫 바이트에 부여되는 번호
    - TCP 세그먼트의 순서를 나타내기 위한 정보
  - 초기 순서 번호
    - 처음 통신을 위해 연결을 수립한 경우 (제어 비트에서 연결을 수립하기 위한 비트인 SYN 플래그가 1로 설정된 세그먼트의 경우), 순서 번호는 무작위 값
    - 이 값이 초기 순서 번호
  - 연결 수립 이후 데이터를 송신하는 동안 순서 번호는 송신한 바이트를 더해 가는 형태로 누적값: 순서 번호 = 초기 순서 번호 + 송신한 바이트 수
  - e.g.: 1900 바이트의 데이터를 전송할 때 (MMS는 500바이트)
    - 세그먼트 A, B, C, D 4개의 세그먼트로 쪼개어 전송 (A, B, C는 500바이트, D는 400바이트)
    - 초기 순서 번호가 100이라고 하면 세그먼트 A의 순서 번호 (초기 순서 번호)는 100
    - 세그먼트 B의 순서번호는 600, C는 1100, D는 1600
- 확인 응답 번호
  - 확인 응답 번호 필드에 명시
  - 순서 번호에 대한 응답
  - 수신자가 다음으로 받기를 기대하는 순서 번호 ('제가 다음으로 받을 순서 번호는 이것입니다.')
  - 일반적으로 '수신한 순서 번호 + 1'로 설정
  - **확인 응답 번호 값을 보내기 위해서는 제어 비트에서 승인을 나타내는 번호인 ACK 플래그를 1로 설정해야 함**
<br/>

## TCP 연결 수립과 종료
### 연결 수립: 쓰리 웨이 핸드셰이크
- 쓰리 웨이 핸드셰이크 (three-way handshake): 세 개의 단계로 이루어진 TCP의 연결 수립 과정
![스크린샷 2025-04-01 135857](https://github.com/user-attachments/assets/845693c5-051c-4a91-a88d-0ca637b4e038)

|송수신 방향|세그먼트|세그먼트에 포함된 주요 정보|비유|
|---|---|---|---|
|A → B|SYN 세그먼트|- A의 초기 순서 번호 <br/> - 1로 설정된 SYN 비트|"연결을 시작합니다."|
|B → A|SYN + ACK 세그먼트|- B의 초기 순서 번호 <br/> - A가 전송한 세그먼트에 대한 확인 응답 번호 <br/> - 1로 설정된 SYN 비트 <br/> - 1로 설정된 ACK 비트|"네 확인했습니다. 연결 시작해요!"|
|A → B|ACK 세그먼트|- A의 다음 순서 번호 <br/> - B가 전송한 세그먼트에 대한 확인 응답 번호 <br/> - 1로 설정된 ACK 비트 | "네. 확인했습니다." |
- 액티브 오픈 (active open)
  - 처음 연결을 시작하는 호스트의 연결 수립 과정
  - 연결을 처음 요청하는 측의 동작
  - 주로 서버 - 클라이언트 관계에서 클라이언트에 의해 수행
- 패시브 오픈 (passive open)
  - 연결 요청을 받고 나서 요청에 따라 연결을 수립
  - 주로 서버에 의해 수행
### 연결 종료 
![스크린샷 2025-04-01 135932](https://github.com/user-attachments/assets/16007674-3d7f-4447-8779-ea1bf298eb4d)
|송수신 방향|세그먼트|세그먼트에 포함된 주요 정보|비유| 
|---|---|---|---|
|A → B|FIN 세그먼트|- 1로 설정된 FIN 비트|"연결 끊을게요."|
|B → A|ACK 세그먼트|- A가 전송한 세그먼트에 대한 확인 응답 번호 <br/> - 1로 설정된 ACK 비트|"네. 확인했습니다."|
|B → A|FIN 세그먼트|- 1로 설정된 FIN 비트|"연결 끊을게요."|
|A → B|ACK 세그먼트|- B가 전송한 세그먼트에 대한 확인 응답 번호 <br/> - 1로 설정된 ACK 비트|"네. 확인했습니다."|
- 액티브 클로즈 (active close): 먼저 연결을 종료하려는 호스트에 의해 수행
- 패시브 클로즈 (passive close): 연결 종료 요청을 받아들이는 호스트에 의해 수행
<br/>

## TCP 상태
- 상태 (state): 현재 어떤 통신 과정에 있는지 나타내는 정보
- 스테이트풀 프로토콜 (stateful protocol): TCP는 상태를 유지하고 활용
### 연결이 수립되지 않은 상태
- CLOSED: 아무런 연결이 없는 상태
- LISTEND
  - 일종의 연결 대기 상태
  - SYN 세그먼트를 기다리는 상태
  - 일반적으로 서버로서 동작하는 패시브 오픈 호스트는 LISTEN 상태를 유지
  - 액티브 오픈 호스트 (일반적으로 호스트)가 LISTEN 상태인 호스트 (일반적으로 서버)에게 SYN 세그먼트를 보내면 쓰리 웨이 핸드셰이크 시작
### 연결 수립 상태
![스크린샷 2025-04-01 140953](https://github.com/user-attachments/assets/aaf5de4a-de54-4d08-ae53-054d1a3388e9)
- SYN-SENT
  - 액티브 오픈 호스트가 SYN 세그먼트를 보낸 뒤 그에 대한 응답인 SYN + ACK 세그먼트를 기다리는 상태
  - 연결 요청을 보낸 뒤 대기 상태
- SYN-RECEIVED
  - 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤 그에 대한 ACK 세그먼트를 기다리는 상태
- ESTABLISHED
  - 연결이 확립되었음을 나타내는 상태
  - 두 호스트가 마지막 ACK 세그먼트를 주고받으면 ESTABLISHED 상태
### 연결 종료 상태
![스크린샷 2025-04-01 141003](https://github.com/user-attachments/assets/784be970-1145-4a16-87f4-07a7642d2208)
- FIN-WAIT-1
  - FIN 세그먼트로서 연결 종료 요청을 보낸 액티브 클로즈 호스트는 FIN-WAIT-1 상태
- CLOSE-WAIT
  - FIN 세그먼트를 받은 패시브 클로즈 호스트가 그에 대한 응답으로 ACK 세그먼트를 보낸 후 대기하는 상태
- FIN-WAIT-2
  - FIN-WAIT-1 상태에서 ACK 세그먼트를 받으면 FIN-WAIT-2 상태
  - 상대 호스트의 FIN 세그먼트를 기다리는 상태
- LAST-ACK
  - CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 이에 대한 ACK 세그먼트를 기다리는 상태
  - LAST - ACK 상태의 패시브 클로즈 호스트는 ACK 세그먼트를 받으면 바로 CLOSED 상태로 전이
- TIME-WAIT
  - 액티브 클로즈 호스트가 FIN 세그먼트를 수신한 뒤, 이에 대한 ACK 세그먼트를 전송한 뒤 접어드는 상태
  - ⚠️ TIME-WAIT 상태의 액티브 클로즈 호스트는 일정한 시간을 기다린 뒤 CLOSED 상태로 전이
    - 상대 호스트가 받았어야 할 마지막 ACK 세그먼트가 올바르게 전송되지 않았을 수 있기 때문
- CLOSING
  - 보통 동시에 연결을 종료하려 할 때 전이되는 상태
  - 서로 FIN 세그먼트를 보내고 받은 뒤 각자 그에 대한 ACK 세그먼트를 보냈지만, 아직 자신의 FIN 세그먼트에 대한 ACK 세그먼트를 받지 못했을 때 접어드는 상태
  - ACK 세그먼트를 수신하면 각자 TIME-WAIT 상태로 접어든 후 종료
<br/>

## UDP 데이터그램 구조
- UDP: 비연결형 통신을 수행하는 신뢰할 수 없는 프로토콜
- 스테이트리스 프로토콜 (stateless protocol): UDP는 상태를 유지하지도, 활용하지도 않음
- UDP 데이터그램 헤더
  - 송신지 포트 & 수신지 포트
  - 길이: 헤더를 포함한 UDP 데이터그램의 바이트
  - 체크섬
    - 데이터그램 전송 과정에서 오류가 발생했는지 검사하기 위한 필드
    - '수신지까지 잘 도착했는지'를 나타내는 신뢰성/비신뢰성과는 관련 ❌
- TCP에 비해 적은 오버헤드로 빠르게 패킷 처리 가능 ➡️ 실시간성이 강조되는 상황에서 많이 사용 (e.g. 스트리밍 서비스, 인터넷 전화)


