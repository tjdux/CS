- 필드 라인에는 HTTP 헤더들이 명시
- HTTP 헤더 이름: 헤더 값
## HTTP 헤더
### 요청 시 활용되는 HTTP 헤더
- Host
  - 요청을 받을 호스트를 나타내는 헤더
  - 주로 도메인 네임으로 명시되며, 포트 번호가 포함되어 있을 수 있음
- User-agent
  - 유저 에이전트 (user-agent): 웹 브라우저와 같이 HTTP 요청을 시작하는 클라이언트 측의 프로그램
  - 요청 메시지 생성에 관여한 클라이언트 프로그램과 관련된 다양한 정보가 명시
  - 서버 입장에서는 User-agent 헤더를 통해 클라이언트의 접속 환경 유추 가능
- Referer
  - 클라이언트가 요청을 보낼 때 머무르고 있던 URL이 명시
  - Referer를 통해 클라이언트의 유입 경로 파악 가능
  - ⚠️ Referrer가 맞는 스페링이지만, 초기 개발 당시 오타로 인해 Referer라는 표기가 오늘날까지 사용되고 있음
- Authorization
  - 클라이언트의 인증 정보를 담는 헤더
  - `Authorization: <type> <credentials>`: 인증 타입 (type)과 인증을 위한 정보 (credentials)가 차례로 명시
  - 인증 타입에 따라 인증 정보에 명시될 값이 달라짐
  - 기본적인 HTTP 인증 타입은 Basic
    - `username:password`와 같이 사용자 아이디와 비밀번호를 콜론을 이용해 합친 뒤, 이를 Base64 인코딩한 값을 인증 정보(credential)로 삼는 방식
    - Base64 인코딩: 문자를 코드로 변환하는 방법을 의미하는 인코딩 방식의 일종
    - `Authorization: Basic c2VveWVvbjoxMjM0`
### 응답 시 활용되는 HTTP 헤더
- Server
  - 요청을 처리하는 서버 측의 소프트웨어와 관련된 정보를 명시
- Allow
  - 클라이언트에게 허용된 HTTP 메서드 목록을 알려 주기 위해 사용
  - 상태 코드 405(Method Not Allowed)를 응답하는 메시지에서 사용
- Retry-After
  - 자원을 사용할 수 있는 날짜 혹은 시각 
  - 상태 코드 503(Server Unavailable)과 함께 사용
- Location
  - 클라이언트에게 자원의 위치를 알려 주기 위해 사용
  - 주로 리다이렉션이 발생했을 때나 새로운 자원이 생성되었을 때 사용
- WWW-Authenticate
  - 자원에 접근하기 위한 인증 방식을 설명하는 헤더
  - 상태 코드 401(Unauthorized)와 함께 사용
  - `WWW-Authenticate: Basic realm="Access to engineering site", charset="UTF-8"`보안 영역(realm)을 함께 알려주거나 인증에 사용될 문자집합(charset)도 알려 줄 수 있음 
    - 영역 (realm)
      - 보안이 적용될 영역
      - 영역이 달라지면 요구되는 권환도 달라질 수 있음
  - Authorization 헤더와 WWW-Authenticate 헤더를 통해 인증되지 않은 클라이언트가 HTTP 인증(Basic 인증)을 수행하는 과정
    1. 인증되지 않은 클라이언트가 서버에 GET 요청 메시지 전송
    2. 서버는 클라이언트에게 상태 코드 401(Unauthorized)과 함께 WWW-Authenticate 헤더를 통해 인증 방식을 알림
    3. 클라이언트는 사용자로부터 인증 정보(사용자 아이디와 비밀번호)를 전달 받음
    4. "사용자 아이디:비밀번호"를 Base64 인코딩한 값을 인증 정보로 삼은 Authorization 헤더를 통해 다시 GET 요청 메시지 전송
    5. 서버는 인증 정보 확인
    6. 인증이 유효하면 상태 코드 200으로 응답하고, 인증되지 않았으면 상태 코드 401로 응답
### 요청과 응답 모두에서 활용되는 HTTP 헤더
- Date
  - 메시지가 생성된 날짜와 시각에 관련된 정보를 담은 헤더
- Connection
  - 클라이언트의 요청과 응답 간의 연결 방식을 설정하는 헤더
  - HTTP는 지속 연결 프로토콜 (킵 얼라이브) ➡️ 이 지속 연결이 Connection에 명시되는 대표적인 연결 방식 `Connection: keep-alive`
  - 서버나 클라이언트가 연결을 종료하고 싶을 떄는 `Connection: close`
- Content-Length
  - 본문의 바이트 단위 크기(길이)
- **Content-Type, Content-Language, Content-Encoding**
  - 표현 헤더(representation header)의 일종: 전송하려는 메시지 본문의 표현 방식을 설명하는 헤더
  1. Content-Type
     - 메시지 본문에서 사용된 미디어 타입을 담고 있음
     - `Content-Type: text/html; charset=UTF-8`: 메시지 본문이 HTML 문서 형식이며, 문자 인코딩으로 UTF-8을 사용
  2. Content-Language
     - 메시지 본문에 사용된 자연어를 명시
     - 언어 태그로 명시되며, 언어 태그는 하이픈(-)으로 구분된 구조
       - 첫 번째 서브 태그는 언어 코드로, 특정 언어를 의미하는 언어 코드가 명시
       - 두 번째 서브 태그는 국가 코드로, 특정 국가를 의미하는 국가 코드가 명시
       - 언어 코드와 국가 코드를 조합하면 '어떤 국가에서 사용하는 어떤 언어'인지 알 수 있음
  3. Content-Encoding
     - 메시지 본문을 압축하거나 변환한 방식이 명시됨
     - 수신 측은 이 헤더를 통해 압축 및 변환 방식을 인식하고, 압축을 해제하거나 원문으로 재변환하여 본문 내용 확인 가능
<br/>

## HTTP 기반 기술
### 캐시
- 캐시 (cache)
  - 불필요한 대역폭 낭비와 응답 지연을 방지하기 위해 정보의 **사본**을 임시로 저장하는 기술
  - 캐시된 데이터를 캐시라 부르기도 함
- 개인 전용 캐시 (private cache): 웹 브라우저에 저장된 캐시
- 공용 캐시 (public cache): 클라이언트와 서버 사이에 위치한 중간 서버에 저장된 캐시
- **캐시는 원본이 아닌 사본을 저장**
  - ➡️ 캐시를 했다면 캐시한 이후로 원본 데이터가 변경되는 상황에 대비
  - 캐시 신선도(cache freshness): 캐시된 사본 데이터가 얼마나 최신 원본 데이터와 유사한지
- 캐시 신선도를 유지하는 가장 기본적인 방법은 '캐시된 데이터에 유효 기간을 설정하는 방법'
  - 캐시 데이터에 유효 기간을 설정하고, 기간이 만료되었다면 원본 데이터를 다시 요청하는 방식으로 캐시 신선도를 유지
  - 캐시할 데이터에 유효 기간을 부여하는 방법: 응답 메시지의 Expires 헤더(날짜) & Cache-Control 헤더의 Max-Age 값(초)
- 캐시 신선도를 재검사하는 방법
  - 캐시가 만료되었더라도 캐시된 자원이 여전히 최신 정보라면 클라이언트는 굳이 서버로부터 같은 자원을 응답받을 필요가 없음
  - 유효 기간이 만료되었다면 캐시 신선도를 재검사
  - 1️⃣ 날짜를 기반으로 재검사하는 방식
    - 클라이언트는 If-Modified-Since 헤더를 통해 서버에게 특정 시점 이후로 원본 데이터에 변경이 있었는지 물어볼 수 있음
    - If-Modified-Since 헤더: 특정 시점 이후로 원본에 변경이 있었다면 그때만 새 자원으로 응답하도록 서버에게 요청하는 헤더
    - 서버 입장에서는...
      1. 요청받은 자원이 변경된 경우: 상태 코드 200(Ok)와 함께 새로운 자원을 응답
      2. 요청받은 자원이 변경되지 않은 경우: 메시지 본문 없는 상태 코드 **304(Not Modified)**를 통해 클라이언트에게 자원이 변경되지 않았음을 알림
         - 304(Not Modified)
           - '이미 캐시된 자원이 있으니 캐시된 자원을 참조하세요'
           - 자원의 변경 여부뿐만 아니라 자원의 마지막 변경 시점도 클라이언트에게 알려줄 수 있음 (Last-Modified 헤더: 특정 자원이 마지막으로 수정된 시점) 
      3. 요청받은 자원이 삭제된 경우: 상태 코드 404(Not Found)를 통해 요청한 자원이 존재하지 않음을 알림
  - 2️⃣ 엔티티 태그 (entity tag 이하 Etag)를 사용하는 방법
    - Etag: '자원의 버전'을 식별하기 위한 정보
    - 버전 (version): 유의미한 변경 사항
    - 자원이 변경될 때마다 자원의 버전을 식별하는 Etag 값이 변경됨
    - If-None-Match 헤더: '이 Etag 값과 일치하는 자원이 있니?'
    - 서버 입장에서는...
      1. 요청받은 자원이 변경 된 경우 (Etag 값이 변경됨): 상태 코드 200(Ok)와 함께 변경된 데이터와 Etag 값을 응답
      2. 요청받은 자원이 변경되지 않은 경우 (Etag 값이 동일): 메시지 본문 없는 상태 코드 304(Not Modified)를 응답
      3. 요청받은 자원이 삭제된 경우: 상태 코드 404(Not Found)를 응답
### 쿠키 
- 쿠키 (cookie)
  - 서버에서 생성되어 클라이언트 측에 저장되는 데이터
  - 상태를 유지하지 않는 HTTP의 특성을 보완하기 위한 수단
  - 서버가 클라이언트의 상태를 알 수 있게끔 하는 데이터
  - <이름, 값> 쌍의 형태, 추가로 적용 범위와 만료 기간 등 다양한 속성을 가질 수 있음
- 서버는 쿠키를 생성하여 클라이언트에게 전송하고, 클라이언트는 전달받은 쿠키를 저장해 두었다가 추후 동일한 서버에 보내는 요청 메시지에 쿠키를 포함하여 전송
- 서버는 쿠키 정보를 참고해 두 개의 요청이 같은 클라이언트에서 왔는지, 로그인 상태를 유지하고 있는지 등을 알 수 있음
- 세션 인증 (session authentication)
  - 세션 아이디 (session id): 쿠키를 통해 전달되는 대표적인 정보
  - 세션 인증 순서
    1. 클라이언트는 서버에게 인증 정보 (아이디, 비밀번호 등)을 전송
    2. 인증 정보가 올바르다면 서버는 세션 아이디를 생성해 클라이언트에게 전송
    3. 서버는 생성한 세션 아이디를 데이터베이스 등에 저장
    4. 클라이언트는 추후 요청을 보낼 때 쿠키 내에 세션 아이디를 포함하여 전송
    5. 서버는 쿠키 속 세션 아이디와 저장된 세션 아이디를 비교하여 클라이언트를 식별
- 쿠키 관련 헤더: 응답 메시지의 Set-Cookie 헤더, 요청 메시지의 Cookie 헤더
  - 응답 메시지의 Set-Cookie 헤더
    - 쿠키의 이름, 값과 더불어 세미콜론(;)으로 구분되는 속성들을 전달 가능
    - 한 응답 메시지에 전달할 쿠키가 여러 개라면 여러 개의 Set-Cookie 사용
    - `Set-Cookie: phone=100-100`
    - `Set-Cookie: message=Hello`
  - 요청 메시지의 Cookie 헤더
    - 서버에 전달할 쿠키의 이름과 값을 나타내는 헤더
    - 여러 개의 쿠키 값을 서버에 전달해야 할 때는 세미 콜론(;)을 사용하여 여러 쿠키의 이름-값을 전달 
    - `Cookie: phone=100-100; message=Hello`
- 쿠키는 브라우저에서 저장되고 관리됨
- 쿠키 관련 속성
  - 도메인 (Domain)
    - 쿠키를 사용 가능한 도메인
    - `Set-Cookie: name=seoyeon; domain=example.com`
  - 경로 (path)
    - 같은 도메인이라도 경로별로 쿠키를 구분하여 사용하고 싶을 때
    - path로 지정된 경로와 그의 하위 경로에서 해당 쿠키 정보를 활용 가능
    - `Set-Cookie: name=seoyeon; path=/lecture`
  - Expires / Max-Age
    - Expires
      - 쿠키 만료 시점
      - `Set-Cookie: sessionID=abc123; Expires=Fri, 23 Aug 2025 09:00:00 GMT`
    - Max-Age
      - 초 단위 유효 기간
      - `Set-Cookie: sessionID=abc123; Max-Age=2592000`
    - 유효 기간이 지나면 해당 쿠키는 삭제되어 전달되지 않음
  - Secure & HTTPOnly
    - 쿠키의 한계: 보안
    - Secure
      - HTTPS 프로토콜이 사용되는 경우에만 쿠키가 전송되도록 하는 속성
      - HTTPS 프로토콜: HTTP를 더 안전한 방식으로 전송할 수 있는 프로토콜
    - HTTPOnly
      - HTTP 송수신을 통해서만 쿠키를 이용하도록 제한하는 속성
      - 쿠키 관련 데이터는 자바스크립트를 통해서도 접근 가능
      - 자바스크립트에서 쿠키에 접근하지 못하도록 하는 속성
- 추가: 웹 스토리지 (Web Storage)
  - 쿠키 이외의 클라이언트가 저장하고 클라이언트의 상태를 추측할 수 있는 <키-값> 쌍 형태의 정보
  - 웹 브라우저 내의 저장 공간
  - 일반적으로 쿠키보다 더 큰 데이터 저장 가능
  - 쿠키는 서버로 자동 전송되지만, 웹 스토리지 정보는 서버로 자동 전송되지 않고 필요할 때 조회
  - 세션 스토리지 (Session Storage): 세션이 유지되는 동안 (브라우저가 열려 있는 동안) 유지되는 정보
  - 로컬 스토리지 (Local Storage): 별도로 삭제하지 않는 한 영구적으로 저장이 가능한 정보
### 컨텐츠 협상과 표현
- 컨텐츠 협상 (content negotiation)
  - 같은 URI에 대해 가장 적합한 '자원의 형태'를 제공하는 매커니즘
- 자원의 표현 (representation)
  - 송수신 가능한 자원의 형태
- 콘텐츠 협상은 클라이언트에게 가장 적합한 자원의 표현을 제공하는 매커니즘
- GET 메서드: 자원의 특정 표현을 습득하기 위한 메서드
- 콘텐츠 협상 관련 HTTP 헤더
  - Accept: 선호하는 미디어 타입
  - Accept-Language: 선호하는 언어
  - Accept-Charset 및 Accept-Encoding: 선호하는 문자 인코딩과 압축 방식
- 선호도에 우선 순위 반영 가능: q 값으로 표현
  - Quality Value의 약자
  - 특정 표현을 얼마나 선호하는지를 나타내는 값
  - 생략되었을 경우 1
  - 범위는 0 - 1이며 값이 클수록 높은 우선순위
  - `Accept: text/html, application/xml;q=0.9, text/plain;q=0.6, */*;q=0.5`: HTML, XML, 일반 텍스트 순으로 선호
