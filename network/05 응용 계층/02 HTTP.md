## HTTP의 특성
### 요청-응답 기반 프로토콜
- 클라이언트-서버 구조 기반의 요청-응답 기반 프로토콜
- 클라이언트와 서버가 서로 HTTP 요청 메시지와 HTTP 응답 메시지를 주고받는 구조
- 같은 HTTP 메시지일지라도 HTTP 요청 메시지와 HTTP 응답 메시지는 메시지 형태가 다름
### 미디어 독립적 프로토콜
>The target of an HTTP request is called a "resource". HTTP does not limit the nature of a resource; it merely defines an interface that might be used to interact with resources. Most resources are identified by a Uniform Resources Identifier (URI). - RFC 9110
- HTTP가 요청하는 대상: 자원
- HTTP는 자원의 특성을 제한하지 않으며, 단지 자원과 상호 작용하는 데 사용할 수 있는 인터페이스를 정의할 뿐
- 대부분의 자원은 URI로 식별됨
- ➡️ HTTP는 주고받을 자원의 특성과 무관하게 그저 자원을 주고받을 수단(인터페이스)의 역할만을 수행
- 미디어 타입 (media type 또는 MIME 타입)
  - HTTP에서 메시지로 주고받는 자원의 종류
  - HTTP는 미디어 타입에 특별히 제한을 두지 않고 독립적으로 동작이 가능한 미디어 독립적 프로토콜
  - `type/subtype` 형식
    - type: 데이터의 유형
    - subtype: 주어진 타입에 대한 세부 유형
  - [미디어 타입의 종류](https://www.iana.org/assignments/media-types/media-types.xhtml)
  - 별표(*)는 여러 미디어 타입을 통칭하기 위해 사용
  - `type/subtype;parameter=value` 형식
    - 부가적인 설명을 위해 매개변수를 포함하는 경우도 존재
    - text/html;charset=UTF-8: UTF-8로 인코딩된 HTML 문서 타입 
### 스테이트리스 프로토콜
- 상태를 유지하지 않는 스테이트리스(stateless) 프로토콜
- 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않음
- 클라이언트의 모든 HTTP 요청은 기본적으로 독립적인 요청으로 간주
- 스테이트리스 프로토콜을 사용하는 이유
  - HTTP 서버는 일반적으로 많은 클라이언트와 동시에 상호 작용 → 모든 클라이언트의 상태 정보를 유지하는 것은 서버에 큰 부담
  - 서버가 여러 대로 구성될 수도 있음 → 모든 서버가 모든 클라이언트의 상태 정보를 공유하는 작업은 번거롭고 복잡
  - HTTP가 상태를 유지하는 프로토콜이었다면 클라이언트는 자신의 상태를 기억하는 서버하고만 상호 작용할 수 있게 되어, 특정 클라이언트가 특정 서버에 종속될 수도 → 한 서버에 문제가 발생하면 해당 서버에 종속된 클라이언트는 직전까지의 HTTP 통신 내역을 잃어버리는 상황 발생
  - HTTP의 설계 목표: 확장성 & 견고성
    - **확장성: 필요하다면 언제든 쉽게 서버를 쉽게 추가 가능**
    - **견고성: 서버 중 하나에 문제가 생겨도 쉽게 다른 서버로 대체 가능**
- 스테이트리스 특성을 보완하기 위한 방법: cookie, web storage
### 지속 연결 프로토콜
- 초기 HTTP 버전 (HTTP 1.0 이하)
  - 비지속 연결: TCP 연결을 수립한 후, 요청에 대한 응답을 받으면 연결을 종료
  - 추가적인 요청-응답을 하기 위해서는 다시 TCP 연결을 수립
- 최근 대중적으로 사용되는 HTTP 버전 (HTTP 1.1 이상)
  - 지속 연결 (또는 킵 얼라이브 keep-alive): 하나의 TCP 연결상에서 여러 개의 요청-응답을 주고받을 수 있는 기술
  - 더 빠르게 여러 HTTP 요청과 응답을 처리
<br/>

## HTTP 메시지 구조
![img](https://github.com/user-attachments/assets/e160782d-16a5-47ab-81a8-e3f58ffa304c)
- 시작 라인
  - 요청 라인
    - HTTP 메시지가 HTTP 요청 메시지일 경우의 시작 라인
    - `메서드 (공백) 요청 대상 (공백) HTTP 버전 (줄바꿈)`
      - **메서드** (method)
        - 클라이언트가 서버의 자원(요청 대상)에 대해 수행할 작업의 종류
      - 요청 대상 (request-target)
        - HTTP 요청을 보낼 서버의 자원
        - (쿼리가 포함된) URI의 경로(path) 명시
        - 하위 경로가 없더라도 요청 대상은 슬래시(/)로 표기
      - HTTP 버전 (HTTP-version)
        - 사용된 HTTP 버전
        - `HTTP/<버전>`
  - 상태 라인
    - HTTP 메시지가 HTTP 응답 메시지일 경우의 시작 라인
    - `HTTP 버전 (공백) 상태 코드 (공백) 이유 구문 (줄바꿈)`
      - HTTP 버전 (HTTP-version)
        - 사용된 HTTP 버전
      - **상태 코드** (status code)
        - 요청에 대한 결과를 나타내는 세 자리 정수
      - **이유 구문** (reason phrase)
        - 상태 코드에 대한 문자열 형태의 설명
        - `HTTP/1.1 200 OK`, `HTTP:1.1 404 Not Found`
- 필드 라인 (또는 헤더 라인)
  - 없거나 여러 개
  - 0개 이상의 HTTP 헤더(HTTP header)가 명시
  - HTTP 헤더
    - HTTP 통신에 필요한 부가 정보
    - `헤더 이름: 헤더 값`
- 메시지 본문 (message-body)
  - 존재하지 않을 수도 있음
  - 다양한 콘텐츠 타입이 사용될 수도
<br/>

## HTTP 메서드
- 메서드로 요청을 받았을 때 서버가 어떻게 행동해야 하는지 설계하는 것은 개발자의 몫
  - 어떤 메서드를 구현하지 않을 수 있음
  - 같은 URL에 대해서 메서드별 동작을 여러 개 구현할 수도 
### GET
- 특정 자원을 조회
- 자원을 요청 메시지에 포함: 요청 라인의 '요청 대상', 헤더 라인의 'HOST 헤더'
- 요청 메시지에는 메시지 본문보다 요청 대상에 쿼리 문자열이 사용되는 경우가 다수
### HEAD
- GET과 동일 하지만 헤더만을 응답 받음
- 응답 메시지에 메시지 본문이 포함되지 않음
### POST
- 서버로 하여금 특정 작업을 처리하도록 요청
- 범용성이 매우 넓음
- 처리할 대상은 흔히 메시지 본문으로 명시
- '클라이언트가 서버에 새로운 자원을 생성하고자 할 때' 많이 사용
- 새로운 자원이 생성되면 서버는 응답 메시지의 Location 헤더를 통해 새로 생성된 자원의 위치를 클라이언트에게 알려줌
### PUT
- 덮어쓰기를 요청
- 요청 자원이 없다면 메시지 본문으로 자원을 새롭게 생성하거나, 이미 자원이 존재한다면 메시지 본문으로 자원을 완전히 대체
### PATCH
- 부분적 수정
- 메시지 본문에 맞게 자원이 일부 수정
### DELETE
- 특정 자원을 삭제 
<br/>

## HTTP 상태 코드
- 상태 코드
  - 요청에 대한 결과를 나타내는 세 자리 정수
  - **백의 자리 수를 기준으로 유형을 구분**
### 200번대: 성공 상태 코드
- '요청이 성공했음'을 의미

|상태 코드|이유 구분|설명|
|---|---|---|
|200|Ok|요청이 성공했음|
|201|Created|요청이 성공했으며, 새로운 자원이 생성되었음 <br/> **Location 헤더를 통해 생성된 자원의 위치를 명시**|
|202|Accepted|요청을 잘 받았으나, 아직 요청한 작업을 끝내지 않았음 <br/> 작업 시간이 긴 대용량 파일 업로드 작업이나 배치 작업과 같이 요청 겨로가를 곧바로 응답하기 어려운 상황|
|204|No Content|요청이 성공했지만, 메시지 본문으로 표시할 데이터가 없음|

### 300번대: 리다이렉션 상태 코드
- 리다이렉션 (redirection)
  - 요청을 완수하기 위해 추가적인 조치가 필요한 상태
  - 클라이언트가 요청한 자원이 다른 곳에 있을 때, 클라이언트의 요청으로 다른 곳으로 이동시키는 것
#### 영구적인 리다이렉션
- 자원이 완전히 새로운 곳으로 이동하여 경로가 영구적으로 재지정되는 것
- 기존의 URL에 요청 메시지를 보내면 항상 새로운 URL로 리다이렉트
- 처음 요청을 보낸 URL을 기억할 필요 없음

|상태 코드|이유 구분|설명|
|---|---|---|
|301|Moved Permanently|영구적인 리다이렉션: 재요청 메서드 변경될 수 있음|
|308|Permanent Redirect|영구적인 리다이렉션: 재요청 메서드 변경되지 않음|
#### 일시적인 리다이렉션 
- 자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우에 주로 사용
- 처음 요청을 보낸 URL을 기억해야 함

|상태 코드|이유 구분|설명|
|---|---|---|
|302|Found|일시적 리다이렉션: 재요청 메서드 변경될 수 있음|
|303|See Other|일시적 리다이렉션: 재요청 메서드 GET으로 변경|
|307|Temporary Redirect|일시적 리다이렉션: 재요청 메서드 변경되지 않음|
### 400번대: 클라이언트 에러 상태 코드

|상태 코드|이유 구분|설명|
|---|---|---|
|400|Bad Request|클라이언트의 요청이 잘못되었음|
|401|Unauthorized|요청한 자원에 대한 유효한 인증이 없음 <br/> WWW-Authenticate 헤더를 통해 인증 방법을 알려줘야 함|
|403|Forbidden|요청이 서버에 의해 거부됨 (예: 접근 권한이 없는 경우)|
|404|Not Found|요청받은 자원을 찾을 수 없음 <br/> 자원이 존재하더라도 공개하지 않은 자원에 대해 404를 응답하는 경우도 존재|
|405|Method Not Allowed|요청한 메서드를 지원하지 않음|
### 500번대: 서버 에러 상태 코드

|상태 코드|이유 구분|설명|
|---|---|---|
|500|Internal Server Error|요청을 처리할 수 없음 <br/> 서버 내 에러를 통칭하기도 함|
|502|Bad Gateway|중간 서버의 통신 오류|
|503|Service Unavailable|현재는 요청을 처리할 수 없으나 추후 가능할 수도 있음|
<br/>

## HTTP의 발전: HTTP/0.9에서 HTTP/3.0까지
### HTTP/0.9
- 지금은 거의 사용되지 않는 초창기 HTTP 버전
- 사용 가능한 메서드가 GET 뿐
- 요청 메시지는 한 줄로 구성
- 헤더 지원 ❌
### HTTP/1.0
- HEAD, POST와 같은 GET 이외의 메서드 도입
- 헤더가 지원되기 시작
- 공식적으로는 지속 연결 지원 ❌
### HTTP/1.1
- 지속 연결이 공식적으로 지원
- 다양한 편의 기능 및 사용 가능한 헤더가 추가: 파이프라이닝 기능, 콘텐츠 협상 기능
- 오늘날까지 널리 사용되는 버전
### HTTP/2.0
- HTTP/1.1의 효율과 성능을 높이기 위한 버전
- 헤더를 압축하여 전송
- 바이너리 데이터 기반의 메시지를 송수신
  - HTTP/1.1까지는 메시지가 평문
- 서버 푸시 기능 제공: 클라이언트가 요청하지 않았더라도 미래에 필요할 것으로 예상되는 자원을 미리 전송
- **HOL 블로킹** (Head-Of-Line blocking) 문제 완화
  - HOL 블로킹
    - 같은 큐에 대기하며 순차적으로 처리되는 여러 패킷이 있을 때, 첫 번째 패킷의 처리 지연으로 인해 나머지 패킷들의 처리도 모두 지연되는 문제
    - HTTP/1.1까지의 고질적인 문제
  - 멀티플렉싱 (multiplexing) 기법을 도입해 완화
    - 여러 스트림을 이용해 병렬적으로 메시지를 주고받는 기술
    - 요청과 응답을 주고받는 단위는 하나의 스트림에서 이루어짐
    - 스트림을 여러 개 활용하는 동시에 스트림 별로 독립적인 송수신이 가능
    - 스트림별 메시지들은 꼭 일정한 순서를 유지할 필요가 없음
### HTTP/3.0
- UDP를 기반으로 구현된 QUIC (Quick UDP Internet Connections) 프로토콜을 기반으로 동작 ➡️ 속도 측면에서 큰 개선
- 현재 빠르게 성장하는 포로토콜 메시지 본문에 맞게 자원이 일부 수정
### DELETE
- 특정 자원을 삭제 
<br/>

## HTTP 상태 코드
- 상태 코드
  - 요청에 대한 결과를 나타내는 세 자리 정수
  - **백의 자리 수를 기준으로 유형을 구분**
### 200번대: 성공 상태 코드
- '요청이 성공했음'을 의미

|상태 코드|이유 구분|설명|
|---|---|---|
|200|Ok|요청이 성공했음|
|201|Created|요청이 성공했으며, 새로운 자원이 생성되었음 <br/> **Location 헤더를 통해 생성된 자원의 위치를 명시**|
|202|Accepted|요청을 잘 받았으나, 아직 요청한 작업을 끝내지 않았음 <br/> 작업 시간이 긴 대용량 파일 업로드 작업이나 배치 작업과 같이 요청 겨로가를 곧바로 응답하기 어려운 상황|
|204|No Content|요청이 성공했지만, 메시지 본문으로 표시할 데이터가 없음|

### 300번대: 리다이렉션 상태 코드
- 리다이렉션 (redirection)
  - 요청을 완수하기 위해 추가적인 조치가 필요한 상태
  - 클라이언트가 요청한 자원이 다른 곳에 있을 때, 클라이언트의 요청으로 다른 곳으로 이동시키는 것
#### 영구적인 리다이렉션
- 자원이 완전히 새로운 곳으로 이동하여 경로가 영구적으로 재지정되는 것
- 기존의 URL에 요청 메시지를 보내면 항상 새로운 URL로 리다이렉트
- 처음 요청을 보낸 URL을 기억할 필요 없음

|상태 코드|이유 구분|설명|
|---|---|---|
|301|Moved Permanently|영구적인 리다이렉션: 재요청 메서드 변경될 수 있음|
|308|Permanent Redirect|영구적인 리다이렉션: 재요청 메서드 변경되지 않음|
#### 일시적인 리다이렉션 
- 자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우에 주로 사용
- 처음 요청을 보낸 URL을 기억해야 함

|상태 코드|이유 구분|설명|
|---|---|---|
|302|Found|일시적 리다이렉션: 재요청 메서드 변경될 수 있음|
|303|See Other|일시적 리다이렉션: 재요청 메서드 GET으로 변경|
|307|Temporary Redirect|일시적 리다이렉션: 재요청 메서드 변경되지 않음|
### 400번대: 클라이언트 에러 상태 코드

|상태 코드|이유 구분|설명|
|---|---|---|
|400|Bad Request|클라이언트의 요청이 잘못되었음|
|401|Unauthorized|요청한 자원에 대한 유효한 인증이 없음 <br/> WWW-Authenticate 헤더를 통해 인증 방법을 알려줘야 함|
|403|Forbidden|요청이 서버에 의해 거부됨 (예: 접근 권한이 없는 경우)|
|404|Not Found|요청받은 자원을 찾을 수 없음 <br/> 자원이 존재하더라도 공개하지 않은 자원에 대해 404를 응답하는 경우도 존재|
|405|Method Not Allowed|요청한 메서드를 지원하지 않음|
### 500번대: 서버 에러 상태 코드

|상태 코드|이유 구분|설명|
|---|---|---|
|500|Internal Server Error|요청을 처리할 수 없음 <br/> 서버 내 에러를 통칭하기도 함|
|502|Bad Gateway|중간 서버의 통신 오류|
|503|Service Unavailable|현재는 요청을 처리할 수 없으나 추후 가능할 수도 있음|
<br/>

## HTTP의 발전: HTTP/0.9에서 HTTP/3.0까지
### HTTP/0.9
- 지금은 거의 사용되지 않는 초창기 HTTP 버전
- 사용 가능한 메서드가 GET 뿐
- 요청 메시지는 한 줄로 구성
- 헤더 미지원
### HTTP/1.0
- HEAD, POST와 같은 GET 이외의 메서드 도입
- 헤더가 지원되기 시작
- 공식적으로는 지속 연결 미지원
### HTTP/1.1
- 지속 연결이 공식적으로 지원
- 다양한 편의 기능 및 사용 가능한 헤더가 추가: 파이프라이닝 기능, 콘텐츠 협상 기능
- 오늘날까지 널리 사용되는 버전
### HTTP/2.0
- HTTP/1.1의 효율과 성능을 높이기 위한 버전
- 헤더를 압축하여 전송
- 바이너리 데이터 기반의 메시지를 송수신
  - HTTP/1.1까지는 메시지가 평문
- 서버 푸시 기능 제공: 클라이언트가 요청하지 않았더라도 미래에 필요할 것으로 예상되는 자원을 미리 전송
- **HOL 블로킹** (Head-Of-Line blocking) 문제 완화
  - HOL 블로킹
    - 같은 큐에 대기하며 순차적으로 처리되는 여러 패킷이 있을 때, 첫 번째 패킷의 처리 지연으로 인해 나머지 패킷들의 처리도 모두 지연되는 문제
    - HTTP/1.1까지의 고질적인 문제
  - 멀티플렉싱 (multiplexing) 기법을 도입해 완화
    - 여러 스트림을 이용해 병렬적으로 메시지를 주고받는 기술
    - 요청과 응답을 주고받는 단위는 하나의 스트림에서 이루어짐
    - 스트림을 여러 개 활용하는 동시에 스트림 별로 독립적인 송수신이 가능
    - 스트림별 메시지들은 꼭 일정한 순서를 유지할 필요가 없음
### HTTP/3.0
- UDP를 기반으로 구현된 QUIC (Quick UDP Internet Connections) 프로토콜을 기반으로 동작 ➡️ 속도 측면에서 큰 개선
- 현재 빠르게 성장하는 포로토콜
