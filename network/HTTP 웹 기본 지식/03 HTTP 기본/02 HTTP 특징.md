## 클라이언트 서버 구조

- Request, Response 구조
  - 클라이언트는 서버에 요청 (request)를 보내고, 응답(response)를 대기
  - 서버는 요청 (request) 에 대한 결과를 응답 (resposne)
- 클라이언트와 서버를 개념적으로 분리하는 것이 중요
  - **비즈니스 로직과 데이터는 모두 서버에서 처리**
  - **클라이언트는 ui와 사용성에 집중**
  - **➡️ 클라이언트와 서버가 독립적으로 진화 가능**
    <br/>

## stateless

- stateless
  - 서버가 클라이언트의 상태를 보존❌
  - 클라이언트가 요청할 때 필요한 데이터를 모두 담아서 전달
  - 장점: 서버 확장성 높음 (스케일 아웃 (수평 확장)에 유리)
    - 서버가 바뀌어도 문제 없음
    - 클라이언트 요청이 증가해도 서버 대거 투입 가능
    - 무상태는 응답 서버를 쉽게 바꿀 수 있음 -> **무한한 서버 증설 가능**
  - 단점: 클라이언트가 추가 데이터 전송
  - 실무 한계
    - 모든 것을 무상태로 설계할 수 없는 경우도 존재 (e.g. 로그인 상태 유지)
      - 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지
      - 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지
    - 상태 유지는 최소한만 사용
- stateful
  - 서버가 클라이언트의 이전 상태를 보존
  - 항상 같은 서버가 유지되어야 함
  - 서버가 중간에 바뀌면 장애 (중간에 다른 서버로 바뀔 때 상태 정보를 그 서버에게 미리 알려줘야 함)
    <br/>

## 비연결성 (connectionless)

- 연결을 유지하는 모델: 클라이언트 1, 2, 3,... 이 서버와 계속 TCP/IP 연결을 유지 -> 서버 자원 소모 多
- 연결을 유지하지 않는 모델: TCP/IP연결을 한 후 요청, 응답 하고 연결 유지 ❌ -> 최소한의 자원 유지
- 비연결성
  - HTTP는 기본이 연결을 유지하지 않는 모델
  - 일반적으로 초 단위 이하의 빠른 속도로 응답
  - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
  - 서버 자원을 매우 효율적으로 사용할 수 있음
  - 한계와 극복
    - TCP/IP 연결을 계속 새로 맺어야 함 ➡️ 3 way handshake 시간 추가
    - 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, CSS, 추가 이미지 등 수 많은 자원이 함께 다운로드
    - 지금은 HTTP 지속 연결 (Persistent Connections)로 문제 해결
      - http 초기: 연결, 종료 낭비 (연결 - 요청/ html 응답 - 종료 - 연결 - 요청/ js 응답 - 종료 - 연결 - 요청/ 이미지 응답 - 종료)
      - http 지속 연결: 연결 - 요청 / html 응답 - 요청 / 자바스크립트 응답 - 요청 / 이미지 응답 - 종료
    - 2.0, 3.0에서는 훨씬 더 많이 최적화
