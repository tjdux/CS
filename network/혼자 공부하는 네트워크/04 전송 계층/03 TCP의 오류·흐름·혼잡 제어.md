- 연결 수립 → 데이터 송수신 → 연결 종료 중 데이터 송수신 과정에서의 오류 제어, 흐름 제어, 혼잡 제어 기법
- TCP의 신뢰성을 보장하기 위한 기능
## 오류 제어: 재전송 기법
### 오류 검출과 재전송
- TCP 세그먼트의 오류 검출을 위한 체크섬 필드는 신뢰성을 보장하기에 부족
  - 세그먼트의 훼손 여부만 나타낼 뿐 세그먼트 전송 과정에 문제가 있다는 것을 알기는 어려움
- TCP의 신뢰성을 보장하기 위해서는
  - 송신 호스트가 송신한 세그먼트에 문제가 발생했음을 인지
  - 오류를 감지하게 되면 해당 세그먼트를 재전송할 수 있어야 함
#### TCP가 오류를 검출하고 세그먼트를 재전송하는 상황
- 중복된 ACK 세그먼트를 수신했을 때
  - 오류가 없다면 호스트 A는 첫 번째 번호를 담은 세그먼트를 보내고, 그에 대한 ACK 세그먼트를 받은 뒤 다음 번호의 세그먼트를 보냄
  - 만일 수신 호스트 측이 받은 세그먼트의 순서 번호 중에서 일부가 누락되었다면 해당 번호에 대한 중복된 ACK 세그먼트를 전송
- 타임아웃이 발생했을 때
  - 송신하는 호스트는 모두 재전송 타이머 (retransmission timer)라는 값을 유지
  - 타임아웃 (time out): 세그먼트를 전송할 때마다 재전송 타이머를 시작하게 되는데, 이 타이머의 카운트다운이 끝난 상황 (정해진 시간이 끝난 상황)
  - 타임아웃이 발생 했을 때까지 ACK 세그먼트를 받지 못했다면 오류를 검출하고 세그먼트를 재전송
### ARQ: 재전송 기법
- ARQ (Automatic Repeat Request 자동 재전송 요구)
  - 수신 호스트의 답변 (ACK)과 타임아웃 발생을 토대로 문제를 진단하고, 문제가 생긴 메시지를 재전송함으로써 신뢰성을 확보하는 방식
  - TCP는 ARQ를 사용하는 대표적인 프로토콜이지만, ARQ 자체는 전송 계층만의 기술은 아님
#### ARQ의 세 가지 방식
- Stop-and-wait ARQ
  - 제대로 전달했음을 확인하기 전까지는 새로운 메시지를 보내지 않는 방식
  - 보낸 메시지에 대한 ACK 세그먼트를 받고 그 다음 메시지를 송신
  - ➕ **단순하지만, 높은 신뢰성 보장**
  - ➖ **낮은 네트워크의 이용 효율**
- Go-Back-N ARQ
  - 파이프라이닝 (pipelining): 연속해서 메시지를 전송할 수 있는 기술
  - 파이프라이닝 방식을 활용해 여러 세그먼트를 전송하고, 도중에 잘못 전송된 세그먼트가 발생할 경우 해당 세그먼트부터 전부 다시 전송하는 방식
  - 누적 확인 응답(CACK; Cumulative Acknowledgment): Go-Back-N ARQ에서 순서 번호 n에 대한 ACK 세그먼트는 'n번까지의' 확인 응답
- Selective Repeat ARQ
  - 파이프라이닝 방식 활용, 오류가 생겼을 시 선택적으로 재전송하는 방식
  - ACK 응답을 받지 못한 세그먼트가 존재한다면 해당 세그먼트를 재전송 
  - 개별 확인 응답 (Selective Acknowledgment): 수신 호스트 측에서 제대로 전송받은 각각의 패킷들에 대해 ACK 세그먼트를 보내는 방식
  - 오늘날 대부분의 호스트는 Selective Repeat ARQ 사용, Selective Repeat ARQ를 사용하지 못한다면 Go-Back-N ARQ 사용
#### 빠른 재전송
- 재전송 타이머가 만료되기 전이라도 세 번의 동일한 ACK 세그먼트가 수신되었다면 해당 세그먼트를 곧바로 재전송하는 기능
- 시간 낭비를 줄이며 빠르게 손실된 세그먼트를 재전송함으로써 성능을 높이는 기능
<br/>

## 흐름 제어: 슬라이딩 윈도우
- 호스트가 한 번에 받아서 처리할 수 있는 세그먼트의 양에는 한계가 존재
  - 수신 호스트가 한 번에 n개의 바이트를 받아서 처리할 수 있다면, 송신 호스트는 n 바이트를 넘지 않는 한에서 송신해야 함
  - 한계보다 많은 세그먼트를 전송한다면 일부 세그먼트가 처리되지 못할 수도 있음
- 수신 버퍼 : 수신된 세그먼트가 애플리케이션 프로세스에 의해 읽히기 전에 임시로 저장되는 공간
- 버퍼 오버플로 (buffer overflow): 수신 버퍼의 크기보다 많은 데이터를 전송하면 일부 세그먼트가 처리되지 못할 수 있음
- TCP 흐름 제어: 송신 호스트가 수신 호스트의 처리 속도를 고려하며 송수신 속도를 균일하게 유지하는 기능
  - Stop-and-wait ARQ는 별도의 흐름 제어가 필요하지 않음
  - 파이프라이닝 기반의 Go-Back-N ARQ, Selective Repeat ARQ는 흐름 제어 필요
- 흐름 제어를 위해 **슬라이딩 윈도우 (sliding window)** 사용
  - 윈도우
    - 송신 호스트가 파이프라이닝할 수 있는 최대량
    - 윈도우의 크기만큼 확인 응답을 받지 않고도 한 번에 전송 가능
  - ACK 응답을 받았다면 윈도우를 한 칸씩 움직이며 세그먼트 전송
- 수신 호스트도 윈도우를 고려
  - 흐름 제어의 주체: 수신 호스트
  - 송신 측 윈도우는 수신 측 윈도우를 토대로 알 수 있는 정보
  - TCP 세그먼트의 윈도우 필드
    - 수신 윈도우의 크기가 명시
    - 한 번에 수신하고자 하는 데이터의 양
  - 수신 호스트는 TCP 헤더의 윈도우 필드를 통해 송신 호스트에게 자신이 받아들이고자 하는 데이터의 양을 알림
  - 송신 호스트는 이 정보를 바탕으로 수신 호스트의 처리 속도와 발맞춰 균일한 속도로 세그먼트를 전송
  - 파이프라이닝 과정에서 송수신 윈도우는 점차 오른쪽으로 미끄러지듯 움직이게 됨
<br/>

## 혼잡 제어
- 혼잡 (congestion): 많은 트래픽으로 인해 패킷의 처리 속도가 늦어지거나 유실될 우려가 있는 네트워크 상황
- 혼잡 붕괴 (congestion collapse): 혼잡으로 인해 전송률이 크게 떨어지는 현상
- 혼잡 제어 (congestion control): 혼잡을 제어하기 위한 기능
  - 혼잡 제어의 주체: 송신 호스트
  - 송신 호스트는 네트워크 혼잡도를 판단하고 혼잡한 정도에 맞춰 유동적으로 전송량을 조절하며 전송
- 혼잡 윈도우: 혼잡 없이 전송할 수 있을 법한 데이터의 양
- 혼잡 제어 알고리즘: 혼잡 윈도우의 크기를 결정
### 혼잡 알고리즘
#### AIMD
- 가장 기본적인 알고리즘
- Additive Increase / Multiplicative Decrease: 합으로 증가, 곱으로 감소
- 혼잡이 감지되지 않는다면 혼잡 윈도우를 RTT (Round Trip Time)마다 1씩 선형적으로 증가
  - **RTT**: 메시지를 전송한 뒤 그에 대한 답변을 받는 데까지 걸리는 시간
- 혼잡이 감지되면 (오류를 감지하는 상황과 동일) 혼잡 윈도우를 절반으로 떨어뜨림
#### 느린 시작 알고리즘
- 혼잡 윈도우를 1부터 시작해 문제없이 수신된 ACK 세그먼트 하나당 1씩 증가시키는 방식
- 결과적으로 혼잡 윈도우는 RTT마다 2배씩 지수적으로 증가
- ➕ 초기 전송 속도를 어느 정도 빠르게 확보 가능
- 혼잡 윈도우를 계속 지수적으로 증가시킬 수는 없음

|상황 분류|방법|
|---|---|
|타임아웃 발생|혼잡 윈도우 값을 1로, 느린 시작 임계치를 혼잡이 감지되었을 시점의 혼잡 윈도우 값의 절반으로 초기화한 뒤 느린 시작 재개|
|혼잡 윈도우 ≥ 느린 시작 임계치|느린 시작 종료, 혼잡 윈도우를 절반으로 초기화한 뒤 혼잡 회피 수행|
|세 번의 중복 ACK 발생|(빠른 재전송 후) 빠른 회복 수행|
#### 혼잡 회피 알고리즘 
- RTT마다 혼잡 윈도우를 1MSS씩 증가시키는 알고리즘
- 혼잡 윈도우의 크기가 선형적으로 증가
- 조심해서 혼잡 윈도우를 증가시키는 방식
#### 빠른 회복 알고리즘
- 세 번의 중복 ACK 세그먼트를 수신했을 때 느린 시작은 건너뛰고 혼잡 회피를 수행하는 알고리즘
- 빠르게 전송률을 회복하기 위한 알고리즘 
<br/>

## ECN: 명시적 혼잡 알림
- 혼잡 알고리즘: 혼잡 제어의 주체는 오로지 송신 호스트의 몫
- 명시적 혼잡 알림 (ECN; Explicit Congestion Notification): 네트워크 중간 장치 (주로 라우터)의 도움을 받는 방법
- 선택적인 기능
- ECN을 지원하는 호스트가 TCP/IP 프로토콜로 정보를 주고받을 때, IP 헤더와 TCP 헤더에 ECN 관련 필드가 추가
  - IP 헤더: 서비스 필드 내 오른 쪽 두 비트가 ECN으로 사용
  - TCP 헤더: 제어 비트의 CWR 비트, ECE 비트가 ECN으로 사용
- 호스트 A ↔ 호스트 B가 ECN을 지원할 때의 동작
  - 호스트 A → 호스트 B에게 메시지를 전송하기 위해 라우터에게 메시지를 보냄
  - 라우터 입장에서 네트워크가 혼잡해질 것 같다고 판단한 경우, IP 헤더의 ECN 비트들을 11로 설정하여 호스트 B에게 메시지 전달
  - 호스트 B가 전달받은 IP 패킷 내에 혼잡 표시가 되어 있다면, TCP ACK 세그먼트 내 ECE 비트를 1로 설정하여 송신 호스트에게 네트워크 혼잡을 알림
  - 송신 호스트가 응답받은 세그먼트에서 ECE 비트가 설정되어 있을 경우, 송신 호스트는 TCP 세그먼트내의 CWR 비트를 1로 설정한 후 혼잡 윈도우를 반으로 줄임
- ➕ 수신 호스트의 ACK 세그먼트를 통해 혼잡을 더 빠르게 감지 가능 
