## 암호와 인증서
- 암호화 (encryption): 원문 데이터 → 암호화된 데이터
- 복호화 (decryption): 암호화된 데이터 → 원문 데이터
### 대칭 키 암호화 방식와 공개 키 암호화 방식
- 암호화 알고리즘: 키와 원문 데이터에 수학적 연산 과정을 거치면 암호문이 생성
#### 대칭 키 암호화 (symmetric key cryptography)
- 암호화와 복호화에 동일한 키 사용
- 장점: 적은 부하 덕분에 암호화 및 복호화를 빠르게 수행
- 단점: 상대방에게 안전하게 키를 전달하기 어려움
#### 공개 키 암호화 (public key cryptography)
- 비대칭 키 암호화(asymmetric key cryptography)라고도 함
- 암호화를 위한 키와 복호화를 위한 키가 다름 (한 키로는 다른 키 유추 불가능)
  - 공개 키 (public key)
    - 암호화를 위한 키
    - 누구에게나 공개해도 무방
  - 개인 키 (private key)
    - 복호화를 위한 키
    - 절대로 유출되지 않도록 보안 유지
- A가 B에게 공개 키 암호화를 통해 문자열 전송 가정
  - 1️⃣ A가 B에게 공개 키를 요청하고 B는 A에게 공개 키 전달
  - 2️⃣ A는 전달받은 B의 공개 키로 메시지를 암호화한 뒤 그 암호문을 B에게 전달
  - 3️⃣ B는 개인 키로 암호를 복호화하여 문자열 확인
- 장점: 키를 안전하게 공유
- 단점: 암호화 및 복호화에 시간과 부하가 상대적으로 많이 듦
#### 세션 키 (session key)
- 장단점을 고려하여 대칭 키 암호화 방식과 공개 키 암호화 방식을 함께 사용
- 대칭 키를 안전하게 전달하기 위해 공개 키로 대칭 키를 암호화하고, 개인 키로 암호화된 대칭 키를 복호화
### 인증서와 디지털 서명
- 공개 키 인증서 (public key certificate)
  - 공개 키와 공개 키의 유효성을 입증하기 위한 전자 문서
  - 공개 키를 누가 생성했는지, 조작되지는 않았는지, 유효 기간은 언제까지인지 등의 내용을 포함
  - 공개 키와 함께 공개 키 인증서를 전송
  - 인증 기관 (CA; Certification Authority)에서 발급
    - 인증서의 발급, 검증, 저장과 같은 역할을 수행할 수 있는 공인 기관
- 서명 값 (signature)
  - 공개 키 인증서를 보증하는 내용으로 인증서에 담겨 있음
  - 클라이언트는 이 서명 값을 바탕으로 인증서를 검토
  - 인증서 내용에 대한 해시 값을 CA의 개인 키로 암호화하는 방식으로 만들어짐
- 해시 값
  - 해시 함수를 적용시킨 결과값
  - 해시 함수
    - 임의의 길이의 데이터를 고정된 길이의 데이터로 변환해 주는 함수
    - 대표적인 해시 함수: MD5, SHA-1, SHA-2 ..
    - 특징: 입력 데이터가 조금만 달라져도 완전히 다른 결과 ➡️ 주로 데이터 변조 여부를 검사하는 데 사용
  - 데이터를 송신할 때 '보내고자 하는 데이터'와 '그 데이터에 대한 특정 해시 함수를 적용시킨 해시 값'을 같이 전송한다고 가정
    - 수신자는 전달받은 데이터에 대한 해시 값을 직접 계산한 뒤,
    - 계산 결과가 전달 받은 해시 값과 같으면 데이터가 변조되거나 소실되지 않았다고 판단
- 웹 브라우저를 통해 서버로부터 서명 값이 붙은 인증서를 전달받았다고 가정
  - 1️⃣ 서명 값과 인증서를 분리
    - 서명값: 인증서 내용에 대한 해시 값을 CA의 **개인 키**로 암호화한 것
    - ➡️ CA의 공개 키로 복호화 가능
  - 2️⃣ 서명 값을 CA의 공개 키로 복호화하면 '인증서 내용에 대한 해시 값'을 얻을 수 있음
  - 3️⃣ 인증서 데이터에 대한 해시 값을 구함
  - 4️⃣ 구한 해시 값을 복호화한 값과 비교
  - 5️⃣ 값이 일치한다면 전달받은 인증서는 CA의 개인 키로 만들어졌다고 보장
- 디지털 서명 (digital signature): 개인 키로 암호화된 메시지를 공개 키로 복호화함으로써 신원을 증명하는 절차
<br/>

## HTTPS: SSL과 TLS
- SSL & TLS
  - 인증과 암호화를 수행하는 프로토콜
  - TLS는 SSL을 계승한 프로토콜 ➡️ SSL과 TLS는 큰 틀에서 보면 유사
  - SSL 2.0, SSL3.0, TLS1.0, TLS1.1, TLS1.2, TLS1.3
- HTTPS
  - SSL/TLS를 사용하는 대표적인 프로토콜
  - HTTP 메시지의 안전한 송수신을 위해 개발된 프로토콜
- TLS 1.3 기반의 HTTPS 동작 순서
  - 1️⃣ TCP 쓰리 웨이 핸드셰이크
  - 2️⃣ TLS 핸드셰이크
    - 핵심
      - 암호화 통신을 위한 키를 교환
      - 인증서 송수신과 검증이 이루어짐
    1. 클라이언트는 ClientHello 메시지를 보냄
       - 암호화된 통신을 위해 서로 맞춰 봐야 할 정보들을 제시
       - 지원되는 TLS 버전, 사용 가능한 암호화 방식과 해시 함수 (암호 스위트 (cipher suite)), 키를 만들기 위해 사용할 클라이언트의 난수 등
    2. 서버는 ServerHello 메시지를 응답으로 보냄
       - 제시된 정보들을 선택하는 메시지
       - 선택된 TLS 버전, 암호 스위트 등의 정보, 키를 만들기 위해 사용할 서버의 난수 등
       - ClientHello 메시지와 ServerHello 메시지를 주고받으면 암호화된 통신을 위해 사전 협의해야 할 정보들이 결정
       - 결정된 정보를 토대로 서버와 클라이언트는 암호화에 사용할 키를 만들 수 있음 ⬅️ TLS 핸드셰이크에서의 키 교환
    3. 서버는 Certificate 메시지와 CertificateVerify 메시지를 전송
       - 인증서와 검증을 위한 디지털 서명
       - 클라이언트는 이 메시지를 토대로 서버의 공개 키를 검증
    4. TLS 핸드셰이크의 마지막을 의미하는 Finished 메시지를 주고 받음
  - 3️⃣ 암호화된 메시지 송수신
    - TLS 1.3에서는 Finished 메시지와 함께 암호화된 메시지 (Application Data) 전송 가능
```pgsql
Client                Server
  | --- ClientHello ---> |
  | <--- ServerHello --- |
  | <--- Certificate --- |
  | <--- CertVerify ---- |
  | --- Finished ------> |
  | <--- Finished ------ |
```
