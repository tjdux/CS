## 프로그램 입출력
- 프로그램 속 명령어로 입출력을 제어하는 방법
- 메모리에 저장된 정보를 하드 디스크에 백업하는 상황
  1. CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령을 보냄
  2. 하드 디스크 컨트롤러는 하드 디스크 상태 확인 후 준비된 상태라면 컨트롤러의 상태 레지스터에 준비되었다고 표시
  3. CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인
  4. 준비 완료 상태라면 백업할 메모리의 정보를 데이터 레지스터에 씀
  5. 아직 백업 작업이 끝나지 않았다면 01번부터 반복하고, 쓰기가 끝났다면 작업을 종료
- CPU가 장치 컨트롤러의 레지스터를 아는 방법: 메모리 맵 입출력, 고립형 입출력
### 메모리 맵 입출력
- 메모리에 접근하기 위한 주소 공간과 입출력 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법
- 메모리 주소 공간이 축소됨
- **CPU는 메모리의 주소들이나 장치 컨트롤러의 레지스터들이나 모두 똑같이 메모리 주소를 대하듯이 하면 됨 ➡️ 메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어가 동일**
### 고립형 입출력
- 메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법
- 메모리 주소 공간이 축소되지 않음
- CPU가 제어 버스의 메모리 읽기/쓰기 선이 활성화되는 명령어를 실행할 때는 메모리에 접근하고, 입출력장치 읽기/쓰기 선이 활성화되는 명령어를 실행할 때는 장치 컨트롤러에 접근
- 메모리에 접근하는 명령어와 다른 입출력 전용 명령어 사용
<br/>

## [인터럽트 기반 입출력](https://github.com/tjdux/CS/blob/main/computer%20architecture/04%20CPU%EC%9D%98%20%EC%9E%91%EB%8F%99%20%EC%9B%90%EB%A6%AC/03%20%EB%AA%85%EB%A0%B9%EC%96%B4%20%EC%82%AC%EC%9D%B4%ED%81%B4%EA%B3%BC%20%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8.md#%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4-%EC%9D%B8%ED%8A%B8%EB%9F%BD%ED%8A%B8)
- 입출력장치에 의한 하드웨어 인터럽트는 장치 컨트롤러에 의해 발생
- cf) 폴링 (polling): 입출력장치의 상태는 어떤지, 처리할 데이터가 있는지 주기적으로 확인하는 방식, 인터럽트 방식보다 더 큰 부담
### 여러 입출력장치에서 동시에 인터럽트가 발생한 경우
- 인터럽트가 발생한 순서대로 처리하는 방법
  - 인터럽트 비트를 비활성한 채 인터럽트를 순차적으로 처리
  - 현실적으로 모든 인터럽트를 전부 순차적으로 해결할 수는 없음
- 인터럽트 간에 우선순위를 고려하여 우선순위가 높은 인터럽트 순으로 여러 인터럽트를 처리
  - 인터럽트 A를 처리하던 중 우선순위가 더 높은 인터럽트 B가 발생하면 A 실행을 잠시 멈추고 B 처리
  - 플래그 레지스터 속 인터럽트 비트가 활성화되어 있는 경우, 또는 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트인 NMI (Non-Maskable Interrupt)가 발생한 경우
### PIC
- 우선순위를 반영하여 다중 인터럽트를 처리하는 경우 PIC (Programmable Interrupt Controller) 하드웨어 사용
- 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에 지금 처리해야 할 하드웨어 인터럽트는 무엇인지를 알려주는 장치
- 일반적으로 PIC를 두 개 이상 계층적으로 구성
- PIC가 NMI까지 우선순위를 판별하지 않음 (NMI는 우선순위가 가장 높아 우선순위 판별이 불필요)
<br/>

## DMA 출력 (Direct Memory Access)
- 입출력장치와 메모리가 CPU를 거치지 않고도 상호작용 할 수 있는 입출력 방식
- 등장 배경
  - 프로그램 기반 입출력과 인터럽트 기반 입출력의 공통점: 입출력 장치와 메모리 간의 데이터 이동은 CPU가 주도하고, 이동하는 데이터도 반드시 CPU를 거침
  - 입출력 장치와 메모리 사이에 전송되는 모든 데이터가 반드시 CPU를 거쳐야 한다면 CPU는 입출력 장치를 위한 연산 때문에 시간을 뺐기게 됨
- DMA 컨트롤러: DMA 입출력을 하기 위해서는 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요
### DMA 입출력 과정
1. CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산, 읽거나 쓸 메모리의 주소 등과 같은 정보로 입출력 작업을 명령
2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행, 이때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 씀
3. 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알림 (CPU는 오로지 입출력의 시작과 끝에만 관여)
- 문제점
  - 시스템 버스는 공용 자원으로 동시 사용이 불가능
  - CPU가 시스템 버스를 사용할 때 DMA 컨트롤러는 시스템 버스를 사용할 수 없고, DMA 컨트롤러가 시스템 버스를 사용할 때 DMA 컨트롤러는 시스템 버스를 사용할 수 없음
  - ➡️ DMA 컨트롤러는 CPU가 시스템 버스를 사용하지 않을 때마다 조금씩 시스템 버스를 이용하거나, CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스를 집중적으로 이용 (사이클 스틸링)
### 입출력 버스
- DMA를 위해 시스템 버스를 너무 자주 사용하면 그만큼 CPU가 시스템 버스를 사용하지 못함
- ➡️ DMA 컨트롤러와 장치 컨트롤러들을 입출력 버스 (input/output bus)라는 별도의 버스에 연결하여 해결
- DMA 컨트롤러와 장치 컨트롤러가 서로 데이터를 전송할 때는 시스템 버스를 이용할 필요가 없으므로 시스템 버스의 사용 빈도를 줄일 수 있음
- 대부분의 입출력 장치 (장치 컨트롤러)는 시스템 버스가 아닌 입출력 버스와 연결
- 입출력 버스의 종류: PCI (Peripheral Component Interconnect) 버스, PCI Exprses (PCIe) 버스 등
- ➕ 입출력 채널 (또는 입출력 프로세서): 메모리에 직접 접근할 뿐만 아니라 입출력 명령어를 직접 인출하고, 해석하고, 실행까지 하는 일종의 입출력 전용 CPU 
