## 연산 코드와 오퍼랜드
- 명령어 = 연산 코드 + 오퍼랜드
### 오퍼랜드 (operand)
- 연산에 사용할 데이터 / 연산에 사용할 데이터가 저장된 위치
- **데이터를 직접 명시하기보다는, 많은 경우 연산에 사용할 데이터가 저장된 위치 (메모리 주소 또는 레지스터 이름)이 담김**
  - ➡️ 오퍼랜드 필드를 주소 필드라고 부르기도 함
- 오퍼랜드는 명령어 안에 하나도 없을 수 있고 (0-주소 명령어), 한 개만 있을 수도 있고 (1-주소 명령어), 두 개 또는 세 개 (2-주소 명령어, 3-주소 명령어) 등 여러 개 있을 수 있음
### 연산 코드 (operation code)
- 명령어가 수행할 연산
- 연산 코드 종류
  - 데이터 전송: `MOVE`, `STORE`, `LOAD(FETCH)`, `PUSH` , `POP`
  - 산술 / 논리 연산: `ADD`, `SUBTRACT`, `MULTIPLY`, `DIVIDE`, `INCREMENT`, `DECREMENT`, `AND`, `OR`, `NOT`, `COMPARE`
  - 제어 흐름 변경: `JUMP`, `CONDITIONAL JUMP`, `HALT`, `CALL`, `RETURN`
  - 입출력 제어: `READ(INPUT)`, `WRITE(OUTPUT)`, `START TO`, `TEST TO`
<br/>

## 주소 지정 방식
- 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커짐
  - e.g. 명령어 크기가 16비트, 연산 코드 필드가 4비트인 2-주소 명령어에서는 오퍼랜드 필드 하나에 표현할 수 있는 데이터 크기는 $$2^6$$ 밖에 되지 않음
  - 메모리 주소가 담긴다면 데이터의 크기는 한 메모리 주소에 저장할 수 있는 공간의 크기만큼 커짐 
- 유효 주소 (effective address): 연산 코드에 사용할 데이터가 저장된 위치 (연산의 대상이 되는 데이터가 저장된 위치)
- 주소 지정 방식 (addressing mode): 오퍼랜드 필드에 데이터가 저장된 위치를 명시 할 때 연산에 사용할 데이터 위치를 찾는 방법
### 즉시 주소 지정 방식
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
- 장점: 빠른 속도
- 단점: 표현할 수 있는 데이터의 크기가 작아짐 
### 직접 주소 지정 방식
- 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
- 장점: 즉시 주소 지정 방식보다 데이터의 크기가 커짐
- 단점: 표현할 수 있는 유효 주소에 제한
### 간접 주소 지정 방식
- 유효 주소의 주소(유효 주소가 저장된 메모리의 주소)를 오퍼랜드 필드에 명시하는 방식
- 장점: 표현할 수 있는 유효 주소의 범위가 더 넓어짐
- 단점: 느린 속도
### 레지스터 주소 지정 방식
- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방식 
- **일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠름**
- ➡️ 장점: 직접 주소 지정 방식보다 빠르게 데이터에 접근 가능
- 단점: 표현할 수 있는 레지스터 크기에 제한
### 레지스터 간접 주소 지정 방식
- 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식
- 장점: 메모리에 접근하는 횟수가 한 번으로 줄어듦 ➡️ 간접 주소 지정 방식보다 빠른 속도
<br/>

## 스택과 큐
### 스택 (stack)
- 나중에 저장한 데이터를 가장 먼저 빼내는 데이터 관리 방식
- 후입선출 (LIFO)
- `PUSH`: 스택에 새로운 데이터를 저장
- `POP`: 스택에 저장된 데이터를 꺼냄
### 큐 (Queue)
- 가장 먼저 저장된 데이터부터 빼내는 데이터 관리 방식
- 선입선출 (FIFO)
