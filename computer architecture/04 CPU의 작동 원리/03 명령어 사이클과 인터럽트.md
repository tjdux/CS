## 명령어 사이클
- 명령어 사이클 (instruction cycle): 하나의 명령어를 처리하는 정형화된 흐름
- 명령어 사이클의 과정
  - 인출 사이클 (fetch cycle): 메모리에 있는 명령어를 CPU로 가지고 오는 단계
  - 실행 사이클 (execution cycle)
    - CPU가 가져온 명령어를 실행하는 단계
    - 제어 장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계
  - 간접 사이클 (indirect cycle)
    - 명령어를 실행하기 위해 메모리 접근을 한 번 더 해야하는 경우
    - e.g. 간접 주소 지정 방식의 경우 인출 사이클을 완료했다고 하더라도 바로 실행 사이클에 돌입할 수 없음 (메모리에 한 번 더 접근 필요)
      - 예: 명령어가 `LOAD [500]` 형태일 때, 주소 500에 있는 값이 아니라 주소 500에 저장된 값이 가리키는 주소의 데이터를 로드해야 하는 경우 → 한 번 더 메모리 접근 필요
- 프로그램을 이루는 명령어는 일반적으로 인출과 실행 사이클을 반복하며 메모리 접근이 더 필요한 경우 간접 사이클을 거쳐 실행
<br/>

## 인터럽트 
- 인터럽트 (interrupt): CPU의 작업을 방해하는 신호
### 동기 인터럽트 (예외)
- CPU에 의해 발생하는 인터럽트
- 폴트 (fault): 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외
- 트랩 (trap): 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외 (주로 디버깅할 때 사용)
- 중단 (abort): CPU가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
- 소프트웨어 인터럽트 (software interupt): 시스템 호출이 발생했을 때 나타나는 예외
### 비동기 인터럽트 (하드웨어 인트럽트)
- 주로 입출력장치에 의해 발생하는 인터럽트
- 입출력 작업 도중에도 CPU가 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트 사용
- 하드웨어 인터럽트 처리 순서
  - 1️⃣ 입출력 장치는 CPU에 **인터럽트 요청 신호**를 보냄
    - 인터럽트 요청 신호: 인터럽트해도 되는지 CPU에 신호 전송
  - 2️⃣ CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인
  - 3️⃣ CPU는 인터럽트 요청을 확인하고 플래그 레지스터의 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는 지 여부를 확인
    - 인터럽트 요청을 수용하기 위해서는 플래그 레지스터의 인터럽트 플래그가 활성화되어 있어야 함
    - **모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아님**
      - 막을 수 없는 인터럽트 (NMI): 정전이나 하드웨어 고장
      - 막을 수 있는 인터럽트 
  - 4️⃣ 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 메모리의 스택영역에 백업
  - 5️⃣ CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행
    - 인터럽트 벡터 (interrupt vector)
      - 인터럽트 서비스 루틴을 식별하기 위한 정보
      - 인터럽트 서비스 루틴의 시작 주소를 포함하기 때문에 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행 가능
      - CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달받음 
    - 인터럽트 서비스 루틴 (ISR; Interrupt Service Routine)
      - 인터럽트를 처리하기 위한 프로그램
      - 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램 
  - 6️⃣ 인터럽트 서비스 루틴 실행이 끝나면 4️⃣에서 백업해 둔 작업을 복구하여 실행을 재개 
