## 선입 선처리 스케줄링
- FCFS 스케줄링 (First Come First Served)
- 먼저 요청한 프로세스부터 (준비 큐에 삽입된 순서대로) CPU를 할당하는 비선점형 스케줄링 방식 
- ➖ 호위효과 (convoy effect): CPU 이용 시간이 긴 프로세스가 먼저 요청하면 그 뒤에 요청한 프로세스는 대기 시간이 길어짐
<br/>

## 최단 작업 우선 스케줄링
- SJF 스케줄링 (Shortest Job First)
- 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간이 짧은 프로세스부터 실행
- 기본적으로 비선점형 스케줄링 방식이지만 선점형으로도 구현 가능 (최소 잔여 시간 우선 스케줄링) 
<br/>

## 라운드 로빈 스케줄링
- 선입 선처리 스케줄링 + 타임 슬라이스
  - 타임 슬라이스: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
- 돌아가면서 타임 슬라이스만큼 CPU를 사용하는 선점형 스케줄링 방식
- 타임 슬라이스가 지나도 프로세스가 완료되지 않았다면 큐의 맨 뒤에 다시 삽입, 이때 문맥 교환 발생
- 타임 슬라이스의 크기가 매우 중요
  - ➖ 너무 작으면 잦은 문맥 교환으로 오버헤드 가능성 
  - ➖ 너무 크면 선입 선처리 스케줄링과 다를 바 없이 호위 효과 발생 여지
<br/>

## 최소 잔여 시간 우선 스케줄링
- SRT 스케줄링 (Shortest Remaining Time)
- 선점형 최단 작업 우선 스케줄링
- 각 프로세스의 남은 CPU 버스트 시간을 비교하여, 남은 시간이 더 짧은 프로세스가 먼저 실행되도록 하는 방식
- 새로운 프로세스가 도착하거나 CPU를 사용하는 도중에도 남은 시간이 짧은 프로세스가 있으면 현재 실행 중인 프로세스를 선점할 수 있음
<br/>

## 우선순위 스케줄링
- 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행
- 최단 작업 우선 스케줄링, 최소 잔여 시간 우선 스케줄링 ⊂ 우선순위 스케줄링
- ➖ **기아 현상 (starvation)**
  - 우선순위가 낮은 프로세스는 높은 프로세스들에 의해 실행이 계속해서 연기될 수 있음
  - 방지 기법: **에이징 (aging)**
    - 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
<br/>

## 다단계 큐 스케줄링
- 우선순위 스케줄링의 발전된 형태
- 우선순위 별로 준비 큐를 여러 개 이용하는 스케줄링 방식
- 우선순위가 높은 큐부터 차례대로 CPU 할당
- ➕ 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리
- ➕ 큐 별로 다른 타임 슬라이스, 스케줄링 알고리즘 사용 가능
- ➖ 기아 현상 발생 가능
  - 프로세스가 큐 사이를 이동 불가
  - 낮은 우선순위의 큐에 있는 프로세스의 경우 계속 연기될 여지
<br/>

## 다단계 피드백 큐 스케줄링
- 프로세스들이 큐 사이를 이동할 수 있음
- CPU 이용 시간이 긴 프로세스는 자연스럽게 우선순위가 낮은 큐로 이동하고, 적은 프로세스는 우선순위가 높은 큐로 이동
  - 한 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행 
- 다단계 큐 스케줄링의 단점을 보완
  - 에이징 기법 적용 가능: 낮은 우선순위 큐에 너무 오래 기다리고 있는 프로세스가 있다면 점차 우선순위가 높은 큐로 이동
- 가장 일반적인 CPU 스케줄링 알고리즘 
