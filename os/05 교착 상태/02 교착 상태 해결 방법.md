- 교착 상태 예방
  - 교착 상태 발생 필요 조건 (상호 배제, 점유와 대기, 비선점, 원형 대기) 중 하나를 충족하지 못하게 하여 교착 상태 발생 가능성을 차단 
    - 1️⃣ 상호 배제 충족 ❌
      - ➖ 현실적으로 어려움 
    - 2️⃣ 점유와 대기 충족 ❌
      - 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않는 방식
      - ➖ 자원의 활용률이 낮아질 우려
      - ➖ 기아 현상 발생 우려: 많은 자원을 필요로 하는 프로세스가 자원을 모두 할당받을 타이밍을 확보하기 어려움
    - 3️⃣ 비선점 조건 충족 ❌
      - 자원을 이용 중인 프로세스로부터 해당 자원을 빼앗을 수 있음
      - ➕ 선점이 가능한 일부 자원 (e.g. CPU)에 대해서는 효과적
      - ➖ 범용성 낮음: 모든 자원이 선점이 가능한 것은 아님 (e.g. 프린터)
    - 4️⃣ 원형 대기 충족 ❌
      - 모든 자원에 번호를 붙이고, 오름차순으로만 요청하도록 강제 
      - ➕ 비교적 현실적이고 실용적인 방법
      - ➖ 모든 자원에 번호를 붙이기 어려움
      - ➖ 어떤 번호를 붙이는지에 따라 특정 자원의 활용률이 떨어질 수 있음
  - ❕교착 상태가 발생하지 않음을 보장할 수는 있지만 여러 부작용 가능성
<br/>

- 교착 상태 회피
  - 교착 상태의 원인을 한정된 자원의 무분별한 할당으로 봄 
  - 자원의 양을 고려하여 교착 상태가 발생하지 않을 정도로만 자원을 조심히 배분
  - 안전 순서열 (safe sequence): 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서
  - 안전 상태 (safe state)
    - 교착 상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태
    - 안전 순서열이 존재하는 상태
  - 불안전 상태 (unsafe state)
    - 교착 상태가 발생할 수도 있는 상태
    - 안전 순서열이 없는 상태
  - 교착 상태를 피하기 위해서는 안전 순서열을 유지하며 자원을 할당
  - 항시 안전 상태를 유지하도록 자원을 할당
    - 은행원 알고리즘 (banker's algorithm): 프로세스의 요청을 승인하기 전에 이 요청을 수락했을 때 시스템이 여전히 안전 상태인지 확인 후 결정 
<br/>

- 교착 상태 검출 후 회복
  - 교착 상태 발생을 인정하고 사후 조치
  - 운영체제는 프로세스들이 자원을 요구할 때마다 모두 할당하며, 교착 상태 발생 여부를 주기적으로 검사
  - 1️⃣ 선점을 통한 회복
    - 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식
    - ➖ 성능 저하 가능성: 자원을 뺏긴 프로세스는 작업이 중단되거나 재시작되어야 하기 때문에 
  - 2️⃣ 프로세스 강제 종료를 통한 회복
    - 교착 상태에 놓인 프로세스를 모두 강제 종료
      - ➕ 교착 상태를 확실하게 해결 가능
      - ➖ 많은 프로세스들의 작업 내역을 잃게 될 가능성
    - 교착 상태가 없어질 때까지 한 프로세스씩 강제 종료
      - ➕ 작업 내역을 잃는 프로세스 최소화
      - ➖ 오버헤드 가능성
<br/>

- 타조 알고리즘
  - 교착 상태 아예 무시
  - 교착 상태 발생 가능성이 낮거나, 해결 비용이 너무 클 때 단순히 무시하는 전략 
