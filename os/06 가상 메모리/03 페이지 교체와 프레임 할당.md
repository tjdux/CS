- 요구 페이징 (demand paging)
  - 프로세스를 메모리에 적재할 때 모든 페이지를 적재하지 않고 필요한 페이지만 메모리에 적재하는 기법
  - 요구 페이지 양상
    - 접근하고자 하는 페이지가 메모리에 있을 경우 (유효비트 1): 해당 프레임에 접근
    - 접근하자 하는 페이지가 메모리에 없을 경우 (유효비트 0): 페이지 폴트 발생 → 페이지 폴트 처리 루틴 (페이지 적재, 유효비트 1)
  - 순수 요구 페이징 (pure demand paging)
    - 아무런 페이지도 적재하지 않고 프로세스 실행
    - 처음에는 페이지 폴트가 계속 발생하다가, 페이지가 어느정도 적재된 후에는 페이지 폴트 발생 빈도 하락
  - 요구 페이징이 안정적으로 작동하기 위해서는 두 가지를 해결
    - 페이지 교체
    - 프레임 할당
<br/>

- 페이지 교체 알고리즘 (page replacement alogrithm)
  - 좋은 페이지 교체 알고리즘: 페이지 폴트가 가장 적게 일어나는 알고리즘
    - → 페이지 폴트 횟수를 알 수 있어야 함
    - → 페이지 참조열 (page reference string)을 통해 페이지 폴트 횟수 알 수 있음
      - 페이지 참조열: CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열
      - 연속된 페이지 생략 이유: 동일한 페이지를 연속적으로 여러 번 참조하는 것은 페이지 폴트를 발생시키지 않기 때문
  - 1️⃣ FIFO 페이지 교체 알고리즘
    - 메모리에 가장 먼저 올라온 페이지부터 페이지 아웃
    - ➖ 프로그램 실행 내내 사용될 페이지를 먼저 올라왔다고 페이지 아웃 시키면 안됨
  - 2️⃣ 2차 기회 페이지 교체 알고리즘
    - FIFO 페이지 교체 알고리즘의 개선
    - 페이지 아웃될 대상 페이지의 참조 비트가 1일 경우, 바로 페이지 아웃시키지 않고 참조 비트를 0으로 바꾼 후 적재 시간을 현재 시간으로 설정 (리스트 끝으로 보냄)하고 교체 대상을 다시 찾음 
  - 3️⃣ 최적 페이지 교체 알고리즘
    - 앞으로 참조될 횟수를 예측하여 교체할 페이지를 선택하는 알고리즘 
    - **앞으로**의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
    - ➕ 가장 낮은 페이지 폴트율 보장
    - ➖ 실제 구현 어려움: 앞으로 오랫동안 사용되지 않을 페이지 예측 어려움
    - ➡️ 실제로 사용되기 보다는, 다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용
      - 최적 페이지 교체 알고리즘의 페이지 폴트 횟수를 페이지 폴트의 하한선으로 간주
  - 4️⃣ LRU 페이지 교체 알고리즘 (Least Recently Used)
    - 가장 오랫동안 사용되지 **않은** 페이지를 교체하는 알고리즘
    - '최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것'이라는 아이디어를 토대로
  <br/>

  - 스레싱 (thrashing)
    - 페이지 폴트가 자주 발생하는 이유
      - 나쁜 페이지 교체 알고리즘
      - **적은 프레임 수**
    - 프레임이 적으면 페이지 폴트 자주 발생 → CPU 이용률 떨어짐 (페이지 교체에 너무 많은 시간) → 성능에 악영향
    - 스레싱: 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제
    - 동시에 실행되는 프로세스의 수 (멀티프로그래밍의 정도)를 늘린다고 해서 무조건 CPU 이용률이 그에 비례해서 증가하는 것이 아님
      - 멀티프로그래밍의 정도가 일정 임계점 (threshold) 이상을 넘어서면, 프레임 부족으로 인해 페이지 폴트가 급격히 증가하고, CPU가 페이지 교체 작업에 과도하게 사용되어 성능이 저하됨
    - 스레싱의 근본적 원인: 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문
  <br/>

  - 프레임 할당 방식
    - 정적 할당 방식
      - 프로세스의 실행과정을 고려하지 않고 프로세스의 크기와 물리 메모리의 크기만 고려한 방식
      - 1️⃣ 균등 할당
        - 모든 프로세스에 균등하게 프레임을 제공
        - ➖ 프로세스마다 크기가 다른데 일률적으로 동일한 프레임 개수를 할당하는 것은 비합리적
      - 2️⃣ 비례 할당
        - 프로세스의 크기에 비례하여 프레임 할당
        - ➖ 프로세스의 크기와 필요로 하는 프레임의 수가 반드시 비례한 것은 아님 (실행해봐야 알 수 있음)
    - 동적 할당 방식
      - 프로세스의 실행을 보고 할당 프레임 수를 결정하는 방식
      - 3️⃣ 작업 집합 모델
        - 작업 집합의 크기만큼만 프레임을 할당
        - 작업 집합: 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합
      - 4️⃣ 페이지 폴드 빈도
        - 할당된 프레임 수와 페이지 폴트율은 반비례 관계
        - 페이지 폴트율에 상한선과 하한선을 정하고, 이 범위 안에서만 프레임을 할당하는 방식 
