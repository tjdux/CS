- 가상 메모리 (virtual memeory)
  - 실행하고자 하는 프로그램의 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
  - 페이징, 세그멘테이션
<br/>

- 페이징 (paging)
  - 연속 메모리 할당에서 외부 단편화의 원인: 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문
  - 페이징: 프로세스의 논리 주소 공간을 페이지 (page) 라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 프레임 (frame) 이라는 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법
  - 스와핑 사용 가능
    - 페이지 단위로 스왑 인 / 스왑 아웃
    - 스왑 아웃 === 페이지 아웃
    - 스왑 인 === 페이지 인
  - ➡️ 한 프로세스를 실행하기 위해 프로세스 전체 (모든 페이지)가 적재될 필요 없음
  - ➡️ 물리 메모리보다 더 큰 프로세스 실행 가능
<br/>

- 페이지 테이블 (page table)
  - 한 프로세스의 페이지가 메모리에 불연속적으로 배치되면 CPU 입장에서는 다음에 실행할 명령어의 위치를 찾기 어려워짐
  - 페이지 테이블 (page table)
    - 페이지 번호와 프레임 번호를 짝지어 주는 표
    - 어떤 페이지가 어떤 프레임에 할당되어 있는지 알 수 있음
    - 각 프로세스의 페이지 테이블은 메모리에 저장
    - 프로세스가 물리 주소 상에서는 불연속적으로 배치되더라도 논리 주소에서는 연속적으로 배치되도록 하기 위해 이용
  - 내부 단편화 (internal fragmentation)
    - 페이징은 외부 단편화는 해결 할 수 있지만 내부 단편화를 야기할 수 있음
    - 모든 프로세스의 크기가 페이지의 배수가 아님 → 마지막 페이지는 정해진 페이지의 크기보다 작을 수 있음
    - 정해진 페이지의 크기 - 마지막 페이지의 크기의 메모리 낭비
    - 하나의 페이지 크기보다 작은 크기로 발생
  - 페이지 테이블 베이스 레지스터 (PTBR; Page Table Base Register)
    - CPU 내부의 PTBR은 각 프로세스의 페이지 테이블이 적재된 메모리 주소를 가리킴
    - PCB에 PTBR의 값이 저장 
    - 페이지 테이블을 메모리에 두었을 때 문제점
      - ➖ 메모리 접근 시간이 두배
        - 페이지 테이블에 접근 + 프레임에 접근
  - TLB (Translation Lookaside Buffer)
    - 페이지 테이블을 메모리에 두었을 때 문제점을 해결하기 위해 CPU 곁에 (일반적으로 MMU) 내에 두는 페이지 테이블의 캐시 메모리
    - 페이지 테이블의 일부 내용을 저장 (참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와 저장)
    - TLB 히트 (TLB hit)
      - CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우
      - 메모리 접근 한번
    - TLB 미스 (TLB miss)
      - 페이지 번호가 TLB에 없을 경우
      - 메모리 접근 두번
<br/>

- 페이징에서의 주소 변환
  - 특정 주소에 접근하기 위해서 두 가지 정보 필요
    - 1️⃣ 어떤 페이지/프레임에 접근하고 싶은지
    - 2️⃣ 접근하려는 주소가 해당 페이지 / 프레임의 어떤 위치에 있는지
  - 페이징 시스템에서는 모든 논리 주소가 페이지 번호와 변위로 이루어져 있음
    - 페이지 번호
      - 접근하고자 하는 페이지 번호
      - 페이지 테이블을 통해서 해당 페이지가 있는 프레임 번호를 알 수 있음 
    - 변위: 접근하려는 주소가 해당 프레임의 시작 번지로부터 얼만큼 떨어져 있는지
  - 논리 주소 <페이지 번호, 변위> ―페이지 테이블→ 물리 주소 <프레임 번호, 변위>
    - 논리 주소의 변위와 물리 주소의 변위는 동일 값
<br/>

- 페이지 테이블 엔트리
  - 페이지 테이블 엔트리 (PTE; Page Table Entry): 페이지 테이블의 각 행
  - 페이지 테이블에 담기는 정보
    - 1️⃣ 페이지 번호
    - 2️⃣ 프레임 번호
    - 3️⃣ 유효 비트
      - 현재 해당 페이지에 접근 가능한지 여부
      - 해당 페이지가 메모리에 적재되어 있다면 1, 적재되어 있지 않다면 0
      - 페이지 폴트 (page fault): 유효 비트가 0인 페이지에 접근하려고 할 때
    - 4️⃣ 보호 비트
      - 페이지 보호 기능
      - 읽기 / 쓰기 / 실행 가능 여부
    - 5️⃣ 참조 비트: CPU가 이 페이지에 접근한 적이 있는지 여부
    - 6️⃣ 수정 비트
      - 해당 페이지에 데이터를 쓴 적이 있는지 수정 여부
      - 존재 이유: 해당 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야하는지 필요성을 판단하기 위해
        - 수정 비트가 0인 경우: 페이지 아웃 될 때 보조기억장치에 추가 작업 필요 없음 (같은 내용이 보조기억장치에 기록되어 있음)
        - 수정 비트가 1인 경우: 페이지 아웃 될 때 변경된 값을 보조기억장치에 기록해야 함
<br/>

- 쓰기 시 복사 (copy on write)
  - 페이징의 이점: 외부 단편화 해결, 프로세스 간 페이지 공유 가능
  - fork 시스템 호출의 경우
    - 프로세스 간에는 기본적으로 자원을 공유하지 않음
    - 새롭게 생성된 자식 프로세스의 코드 및 데이터 영역은 부모 프로세스가 적재된 메모리 공간과는 다른 메모리 공간에 형성 
    - 각 프로세스의 페이지 테이블은 자신의 고유한 페이지가 할당된 프레임을 가리킴
    - ➖ 긴 프로세스 생성 시간, 불필요한 메모리 낭비
  - 쓰기 시 복사의 경우
    - 부모 프로세스와 동일한 자식 프로세스가 생성되면 자식 프로세스의 페이지 테이블은 부모 프로세스와 동일한 프레임을 가리킴
    - 부모 프로세스의 메모리 공간을 복사하지 않고 동일한 코드 및 데이터 영역을 가리킬 수 있음
    - 읽기 작업만 이어 나간다면 이 상태가 지속
    - 부모 프로세스 / 자식 프로세스 둘 중 하나가 쓰기 작업을 하면 그 순간 해당 페이지가 별도의 공간으로 복제됨
    - ➕ 줄어든 프로세스 생성 시간, 메모리 공간 절약
<br/>

- 계층적 페이징 (hierachical paging)
  - 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 수 있는 방법
  - 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식
  - 페이지 테이블을 여러 개의 페이지로 쪼개고, 이 페이지들을 가리키는 페이지 테이블 (Outer 페이지 테이블)을 두는 방식
  - 계층적 페이징 환경에서의 논리 주소: 바깥 페이지 번호 + 안쪽 페이지 번호 + 변위 
